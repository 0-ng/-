Line Q[1510];
Point p[1510];
Line L[1510];
bool HPIcmp(Line a,Line b) {
    if (fabs(a.ang - b.ang) > EPS)return a.ang < b.ang;
    else return ((a.s - b.s) ^ (b.e - b.s)) < 0;
}
bool HPI(Line line[],int n,Point res[],int &resn) {
    int tot = n;
    sort(line, line + n, HPIcmp);
    tot = 1;
    for (int i = 1; i < n; i++){ // 去掉右边的线段，保留左边的线段。
        if (fabs(line[i].ang - line[i - 1].ang) > EPS)
            line[tot++] = line[i];
    }
    int head = 0, tail = 1;
    Q[0] = line[0];
    Q[1] = line[1];
    resn = 0;
    for (int i = 2; i < tot; i++) {
        if (fabs((Q[tail].e - Q[tail].s) ^ (Q[tail - 1].e - Q[tail - 1].s)) < EPS ||
            fabs((Q[head].e - Q[head].s) ^ (Q[head + 1].e - Q[head + 1].s)) < EPS)
            return false;
        while (head < tail && (((Q[tail] & Q[tail - 1]) - line[i].s) ^ (line[i].e - line[i].s)) > EPS)
            tail--;
        while (head < tail && (((Q[head] & Q[head + 1]) - line[i].s) ^ (line[i].e - line[i].s)) > EPS)
            head++;
        Q[++tail] = line[i];
    }
    while (head < tail && (((Q[tail] & Q[tail - 1]) - Q[head].s) ^ (Q[head].e - Q[head].s)) > EPS)
        tail--;
    while (head < tail && (((Q[head] & Q[head + 1]) - Q[tail].s) ^ (Q[tail].e - Q[tail].s)) > EPS)
        tail--;
    return tail > head + 1;
    //[head,tail]
//    if(tail <= head + 1)return;
//    for (int i = head; i < tail; i++)  // 保存内核点
//        res[resn++] = Q[i] & Q[i + 1];
//    res[resn++] = Q[head] & Q[tail];
}
double CalcArea(Point p[],int n) {
    double ans = 0;
    for (int i = 0; i < n; i++) {
        ans += (p[i] ^ p[(i + 1) % n]) / 2;
    }
    return ans;
}
void solve(){
    int resn=0;
    HPI(L,n,p,resn);
    printf("%.2f\n",CalcArea(p,resn));
}
void init(){
//    scanf("%d",&n);
    for(int i=0;i<n;i++)
        p[i].read();
    if(CalcArea(p,n)<0)
        reverse(p,p+n);
    for(int i=0;i<n;i++)
        L[i]={p[i],p[(i+1)%n]};
}
