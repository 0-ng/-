#include<map>
#include<set>
#include<cmath>
#include<queue>
#include<stack>
#include<ctime>
#include<vector>
#include<cstdio>
#include<vector>
#include<string>
#include<bitset>
#include<cstdlib>
#include<iomanip>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+10;
const double EPS=1e-6;
const double PI=acos(-1);
inline int sgn(double a){ return a < -EPS ? -1 : a > EPS; }
inline int cmp(double a, double b){ return sgn(a-b); }
long long mod=1e9+7;
int INF=0x3f3f3f3f;
int n,m,x;
int a[MAXN];
struct node{
    int e;
    int nxt;
    int w;
    int f;
}edge[MAXN];
int cnt;
int head[MAXN],dis[MAXN],vis[MAXN];
//int pre[MAXN]
int S,T,minfee;
void add(int u,int v,int flow,int cost) {
    edge[cnt].e = v;
    edge[cnt].w = cost;
    edge[cnt].f = flow;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
    cnt++;
}
//bool bfs(){
//    memset(dis,-1, sizeof(dis));
//    dis[1]=0;
//    queue<int>q;
//    q.push(1);
//    while(!q.empty()){
//        int r=q.front();q.pop();
//        for(int i=head[r];i!=-1;i=edge[i].nxt){
//            int j=edge[i].e;
//            if(dis[j]==-1&&edge[i].v){
//                dis[j]=dis[r]+1;
//                q.push(j);
//            }
//        }
//    }
//    return dis[n]!=-1;
//}
bool SPFA(int u,int v){
    memset(dis,0x3f, sizeof(dis));
    memset(vis,false, sizeof(vis));
    dis[u]=0;
    deque<int>d;
    d.push_back(u);
    vis[u]=true;
    
//    a[S]=1e9;
    
    while(!d.empty()){
        int ui=d.front();d.pop_front();
        vis[ui]=false;
        for(int i=head[ui];i!=-1;i=edge[i].nxt){
            int vi=edge[i].e,w=edge[i].w,f=edge[i].f;
            if(f&&dis[vi]>dis[ui]+w){
                dis[vi]=dis[ui]+w;
                
//                pre[vi] = dis[ui]+w;
//                a[vi] = min(a[ui], f);
                
                if(!vis[vi]){
                    if(!d.empty()&&dis[vi]<dis[d.front()])d.push_front(vi);
                    else d.push_back(vi);
                }
            }
        }
    }
    return dis[T]<INF;
}
int dfs(int u,int flow){
    if(u==T) return flow;
    int delta=flow;
    vis[u]=true;
    for(int i=head[u];i!=-1;i=edge[i].nxt){
        int v=edge[i].e,w=edge[i].w,f=edge[i].f;
        if(f&&!vis[v]&&dis[v]==dis[u]+w){
            int d=dfs(v,min(f,delta));
            delta-=d;
            edge[i].f-=d;
            edge[i^1].f+=d;
            minfee+=d*w;
            if(delta==0)break;
        }
    }
    vis[u]=false;
    return flow-delta;
}
int dini() {//求最大流量
    int ans=0;
    while(SPFA(S,T)){
        memset(vis,false, sizeof(vis));
        ans+=dfs(S,INF);
    }
    return ans;
}
void solve(){
    int q,a,b;
    scanf("%d",&q);
    int c=dini();
    while(q--){
        scanf("%d%d",&a,&b);
        if(1.0*c*a/b<1){
            printf("NaN\n");
        }else{
            printf("%.4f %.4f\n",1.0*c*a/b,1.0*minfee*a/b);
            printf("%.4f\n",1.0*minfee*c);
        }
    }
//    printf("%d %d\n",c,minfee);
}
void init(){
//    scanf("%d%d",&n,&m);
    S=1,T=n;
    memset(head,-1, sizeof(head));
    for(int i=1,u,v,w,f;i<=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        add(u,v,1,w);
        add(v,u,-1,0);
    }
}
int main(){
//    freopen("C:\\Users\\0ng\\Downloads\\P3381_8.in","r",stdin);
    int T;
//    scanf("%d",&T);
    T=1;
    while(~scanf("%d%d",&n,&m)){
        init();
        solve();
    }
    return 0;
}
