bool HPIcmp(Line a,Line b) {
    if (fabs(a.ang - b.ang) > EPS)return a.ang < b.ang;
    else return ((a.s - b.s) ^ (b.e - b.s)) < 0;
}
struct halfplanes{
    int n;
    Line line[MAXN];
    Point p[MAXN];
    Line Q[MAXN];
    int head,tail;
    bool HPI() {
        sort(line+1, line+n+1, HPIcmp);
        int tot = 1;
        for (int i = 2; i <= n; i++)
            if (fabs(line[i].ang - line[i - 1].ang) > EPS) //去掉斜率重复的
                line[++tot] = line[i];
        head = 1, tail = 2;
        Q[1] = line[1];Q[2] = line[2];
        for (int i = 3; i <= tot; i++) {
            if (fabs((Q[tail].e - Q[tail].s) ^ (Q[tail - 1].e - Q[tail - 1].s)) < EPS ||
                fabs((Q[head].e - Q[head].s) ^ (Q[head + 1].e - Q[head + 1].s)) < EPS)
                return false;
            while (head < tail && (((Q[tail] & Q[tail - 1]) -
                                    line[i].s) ^ (line[i].e - line[i].s)) > EPS)
                tail--;
            while (head < tail && (((Q[head] & Q[head + 1]) -
                                    line[i].s) ^ (line[i].e - line[i].s)) > EPS)
                head++;
            Q[++tail] = line[i];
        }
        while (head < tail && (((Q[tail] & Q[tail - 1]) -
                                Q[head].s) ^ (Q[head].e - Q[head].s)) > EPS)
            tail--;
        while (head < tail && (((Q[head] & Q[head + 1]) -
                                Q[tail].s) ^ (Q[tail].e - Q[tail].s)) > EPS)
            head++;
        if (tail <= head + 1) return false;
        return true;
    }
    void getConvex(Point res[], int &resn){
        resn=0;
        for(int i = head; i < tail; i++)
            res[++resn] = Q[i]&Q[i+1];
        if(head < tail - 1)
            res[++resn] = Q[head]&Q[tail];
    }
}hpi;
