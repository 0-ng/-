const int LOG=20;
struct Edge{
    int to,w,next;
}edge[MAXN<<1];
int fa[MAXN],head[MAXN],dep[MAXN],dis[MAXN],dp[MAXN][22];
int cnt;
int Find(int x){
    if(x==fa[x]) return x;
    return fa[x]=Find(fa[x]);
}
void add_edge(int from,int to,int val){
    cnt++;
    edge[cnt].to=to;
    edge[cnt].w=val;
    edge[cnt].next=head[from];
    head[from]=cnt;
}
void Union(int x,int y){
    x=Find(x);
    y=Find(y);
    if(x!=y)
        fa[x]=y;
}
void dfs(int u,int pre,int depth){
    dp[u][0]=pre;
    dep[u]=dep[pre]+1;
    dis[u]=depth;
    for(int i=1;(1<<i)<=dep[u];i++)
        dp[u][i]=dp[dp[u][i-1]][i-1];
    for(int i=head[u];~i;i=edge[i].next){
        int v=edge[i].to;
        if(v!=pre)
            dfs(v,u,dis[u]+edge[i].w);
    }
}
int LCA(int a,int b){
    if(dep[a]<dep[b])
        swap(a,b);
    for(int i=LOG;i>=0;i--){
        if(dep[a]-(1<<i)>=dep[b])
            a=dp[a][i];
    }
    if(a==b) return a;
    for(int i=LOG;i>=0;i--){
        if(dp[a][i]!=dp[b][i]){
            a=dp[a][i];
            b=dp[b][i];
        }
    }
    return dp[a][0];
}
void solve(){
    for(int i=1;i<=n;i++)
        if(fa[i]==i)
            dfs(i,0,0);
    int u,v;
    while(c--){
        scanf("%d%d",&u,&v);
        if(Find(u)==Find(v))
            printf("%d\n",dis[u]+dis[v]-dis[LCA(u,v)]*2);
        else
            printf("Not connected\n");
    }
}
void init(){
    cnt=0;
    memset(head,-1, sizeof(head));
    memset(dp,0, sizeof(dp));
    memset(dis,0, sizeof(dis));
    memset(dep,0, sizeof(dep));
    for(int i=1;i<=n;i++)
        fa[i]=i;
    for(int i=1,u,v,w;i<=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        add_edge(u,v,w);
        add_edge(v,u,w);
        Union(u,v);
    }
}
